import React from 'react';
import PropTypes from 'prop-types';
import { Group } from '@vx/group';
import { geoGraticule, geoOrthographic, geoAlbers, geoMercator, geoNaturalEarth1, geoPath } from 'd3-geo';
import cx from 'classnames';

function callOrValue(maybeFn, data) {
  if (typeof maybeFn === 'function') {
    return maybeFn(data);
  }
  return maybeFn;
}

function additionalProps(restProps, data) {
  return Object.keys(restProps).reduce(function (ret, cur) {
    ret[cur] = callOrValue(restProps[cur], data);
    return ret;
  }, {});
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function Graticule(_ref) {
  var graticule = _ref.graticule,
      lines = _ref.lines,
      outline = _ref.outline,
      extent = _ref.extent,
      extentMajor = _ref.extentMajor,
      extentMinor = _ref.extentMinor,
      step = _ref.step,
      stepMajor = _ref.stepMajor,
      stepMinor = _ref.stepMinor,
      precision = _ref.precision,
      restProps = objectWithoutProperties(_ref, ['graticule', 'lines', 'outline', 'extent', 'extentMajor', 'extentMinor', 'step', 'stepMajor', 'stepMinor', 'precision']);

  var currGraticule = geoGraticule();

  if (extent) currGraticule.extent(extent);
  if (extentMajor) currGraticule.extentMajor(extentMajor);
  if (extentMinor) currGraticule.extentMinor(extentMinor);
  if (step) currGraticule.step(step);
  if (stepMajor) currGraticule.stepMajor(stepMajor);
  if (stepMinor) currGraticule.stepMinor(stepMinor);
  if (precision) currGraticule.stepMinor(precision);

  return React.createElement(
    Group,
    { className: 'vx-geo-graticule' },
    graticule && React.createElement('path', _extends({ d: graticule(currGraticule()), fill: 'none', stroke: 'black' }, restProps)),
    lines && currGraticule.lines().map(function (line, i) {
      return React.createElement(
        'g',
        { key: i },
        React.createElement('path', _extends({
          d: lines(line),
          fill: 'none',
          stroke: 'black'
        }, additionalProps(restProps, _extends({}, line, {
          index: i
        }))))
      );
    }),
    outline && React.createElement('path', _extends({ d: outline(currGraticule.outline()), fill: 'none', stroke: 'black' }, restProps))
  );
}

Graticule.propTypes = {
  graticule: PropTypes.func,
  lines: PropTypes.func,
  outline: PropTypes.func
};

// TODO: Implement all projections of d3-geo
var projectionMapping = {
  orthographic: function orthographic() {
    return geoOrthographic();
  },
  albers: function albers() {
    return geoAlbers();
  },
  mercator: function mercator() {
    return geoMercator();
  },
  naturalEarth: function naturalEarth() {
    return geoNaturalEarth1();
  }
};

/**
 * Component for all projections.
 */
function Projection(_ref) {
  var data = _ref.data,
      _ref$projection = _ref.projection,
      projection = _ref$projection === undefined ? 'mercator' : _ref$projection,
      projectionFunc = _ref.projectionFunc,
      clipAngle = _ref.clipAngle,
      clipExtent = _ref.clipExtent,
      scale = _ref.scale,
      translate = _ref.translate,
      center = _ref.center,
      rotate = _ref.rotate,
      precision = _ref.precision,
      fitExtent = _ref.fitExtent,
      fitSize = _ref.fitSize,
      centroid = _ref.centroid,
      graticule = _ref.graticule,
      graticuleLines = _ref.graticuleLines,
      graticuleOutline = _ref.graticuleOutline,
      className = _ref.className,
      innerRef = _ref.innerRef,
      pointRadius = _ref.pointRadius,
      restProps = objectWithoutProperties(_ref, ['data', 'projection', 'projectionFunc', 'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'precision', 'fitExtent', 'fitSize', 'centroid', 'graticule', 'graticuleLines', 'graticuleOutline', 'className', 'innerRef', 'pointRadius']);

  var currProjection = projectionMapping[projection]();

  if (clipAngle) currProjection.clipAngle(clipAngle);
  if (clipExtent) currProjection.clipExtent(clipExtent);
  if (scale) currProjection.scale(scale);
  if (translate) currProjection.translate(translate);
  if (center) currProjection.center(center);
  if (rotate) currProjection.rotate(rotate);
  if (precision) currProjection.rotate(precision);
  if (fitExtent) currProjection.fitExtent.apply(currProjection, toConsumableArray(fitExtent));
  if (fitSize) currProjection.fitSize.apply(currProjection, toConsumableArray(fitSize));

  var path = geoPath().projection(currProjection);

  if (pointRadius) path.pointRadius(pointRadius);

  return React.createElement(
    Group,
    { className: 'vx-geo' },
    graticule && !graticule.foreground && React.createElement(Graticule, _extends({ graticule: function graticule(g) {
        return path(g);
      } }, graticule)),
    graticuleLines && !graticuleLines.foreground && React.createElement(Graticule, _extends({ lines: function lines(g) {
        return path(g);
      } }, graticuleLines)),
    graticuleOutline && !graticuleOutline.foreground && React.createElement(Graticule, _extends({ outline: function outline(g) {
        return path(g);
      } }, graticuleOutline)),
    data.map(function (feature, i) {
      var c = void 0;
      if (centroid) c = path.centroid(feature);
      return React.createElement(
        'g',
        { key: projection + '-' + i },
        React.createElement('path', _extends({
          className: cx('vx-geo-' + projection, className),
          d: path(feature),
          ref: innerRef && innerRef(feature, i)
        }, additionalProps(restProps, _extends({}, feature, {
          index: i,
          centroid: c
        })))),
        centroid && centroid(c, feature)
      );
    }),
    projectionFunc && projectionFunc(currProjection),
    graticule && graticule.foreground && React.createElement(Graticule, _extends({ graticule: function graticule(g) {
        return path(g);
      } }, graticule)),
    graticuleLines && graticuleLines.foreground && React.createElement(Graticule, _extends({ lines: function lines(g) {
        return path(g);
      } }, graticuleLines)),
    graticuleOutline && graticuleOutline.foreground && React.createElement(Graticule, _extends({ outline: function outline(g) {
        return path(g);
      } }, graticuleOutline))
  );
}

Projection.propTypes = {
  data: PropTypes.array.isRequired,
  projection: PropTypes.string,
  projectionFunc: PropTypes.func,
  clipAngle: PropTypes.number,
  clipExtent: PropTypes.array,
  scale: PropTypes.number,
  translate: PropTypes.array,
  center: PropTypes.array,
  rotate: PropTypes.array,
  precision: PropTypes.number,
  fitExtent: PropTypes.array,
  fitSize: PropTypes.array,
  centroid: PropTypes.func,
  className: PropTypes.string
};

function Albers(props) {
  return React.createElement(Projection, _extends({ projection: 'albers' }, props));
}

function Mercator(props) {
  return React.createElement(Projection, _extends({ projection: 'mercator' }, props));
}

function Orthographic(props) {
  return React.createElement(Projection, _extends({ projection: 'orthographic' }, props));
}

function NaturalEarth(props) {
  return React.createElement(Projection, _extends({ projection: 'naturalEarth' }, props));
}

export { Albers, Mercator, Orthographic, NaturalEarth };
